////////////////////////////////////////////////////////////////////// 
// merlin/MerlinCache.cpp 
// (c) 2000-2007 Goncalo Abecasis
// 
// This file is distributed as part of the MERLIN source code package   
// and may not be redistributed in any form, without prior written    
// permission from the author. Permission is granted for you to       
// modify this file for your own personal use, but modified versions  
// must retain this copyright notice and must not be distributed.     
// 
// Permission is granted for you to use this file to compile MERLIN.    
// 
// All computer programs have bugs. Use this file at your own risk.   
// 
// Tuesday December 18, 2007
// 
 
#include "MerlinCache.h"
#include "Houdini.h"

#ifndef VERSION
#define VERSION "Unofficial Release"
#endif

#define  DIRCHAR "/"

String MerlinCache::directory;

MerlinCache::MerlinCache()
   {
   isActive = directory.Length() > 0;
   tag.printf(":%g:%g",
              FuzzyInheritanceTree::perAlleleError,
              FuzzyInheritanceTree::perGenotypeError);

   indexFile = NULL;
   dataFile = NULL;
   }

MerlinCache::~MerlinCache()
   {
   }

bool MerlinCache::IndexMatches(Mantra & m)
   {
   String buffer;
   StringArray tokens;

   // If input files are not available, we have a cache miss
   if (indexFile == NULL || dataFile == NULL)
      return false;

   // A cached version of the family may exist ...

   // First check the Merlin version that generated the index
   buffer.ReadLine(indexFile);
   if (buffer != "Cache generated by MERLIN " VERSION )
      return false;

   // Then check whether the pedigree graph vector matches our current one
   buffer.ReadLine(indexFile);
   tokens.AddTokens(buffer);

   if (tokens.Length() != m.vector.Length() + 1 || tokens[0] != "Vector:")
      return false;

   for (int i = 0; i < m.vector.Length(); i++)
      if (tokens[i + 1].AsInteger() != m.vector[i])
         return false;

   // And finally check that the inheritance graph bits match our current one
   buffer.ReadLine(indexFile);
   tokens.Clear();
   tokens.AddTokens(buffer);

   if (tokens.Length() != m.bits.Length() + 1 || tokens[0] != "Bits:")
      return false;

   for (int i = 0; i < m.bits.Length(); i++)
      if (tokens[i + 1].AsInteger() != m.bits[i])
         return false;

   return true;
   }

void MerlinCache::OpenCache(Mantra & m)
   {
   if (!isActive || m.bit_count < 4) return;

   String      buffer;
   StringArray tokens;
   String      filename = directory + DIRCHAR + m.family->famid;

   indexFile = fopen(filename + ".txt", "r+t");
   dataFile = fopen(filename + ".bin", "r+b");

   if (IndexMatches(m))
      {
      while (!feof(indexFile))
         {
         buffer.ReadLine(indexFile);
         tokens.Clear();
         tokens.AddTokens(buffer);

         if (tokens.Length() != 2)
            continue;

         markers.SetInteger(tokens[0], tokens[1].AsInteger());
         }
      }
   else
      {
      CloseCache();

      indexFile = fopen(filename + ".txt", "w+t");
      dataFile = fopen(filename + ".bin", "w+b");

      if (indexFile == NULL || dataFile == NULL)
         return;

      fprintf(indexFile, "Cache generated by MERLIN " VERSION "\n");
      fprintf(indexFile, "Vector:");
      for (int i = 0; i < m.vector.Length(); i++)
         fprintf(indexFile, " %d", m.vector[i]);
      fprintf(indexFile, "\nBits:");
      for (int i = 0; i < m.bits.Length(); i++)
         fprintf(indexFile, " %d", m.bits[i]);
      fprintf(indexFile, "\n\n");
      }
   }

void MerlinCache::CloseCache()
   {
   if (indexFile != NULL)
      fclose(indexFile);

   if (dataFile != NULL)
      fclose(dataFile);

   dataFile = NULL;
   indexFile = NULL;
   }

void MerlinCache::SaveToCache(Mantra & m, BasicTree & tree, String & marker)
   {
   if (!isActive || dataFile == NULL || indexFile == NULL || m.bit_count < 4)
      return;

   fseek(dataFile, 0, SEEK_END);

   // Log location of the write to index
   fprintf(indexFile, "%s%s %ld\n",
           (const char *) marker, (const char *) tag, (long int) ftell(dataFile));

   // First write out genotypes array
   fwrite(&m.genotype[0], sizeof(m.genotype[0]), m.two_n, dataFile);

   // Then write out allele frequencies
   fwrite(&m.frequencies[0], sizeof(m.frequencies[0]), m.frequencies.Length(), dataFile);

   // Finally, write out inheritance tree
   tree.WriteToFile(dataFile);
   }

bool MerlinCache::RetrieveFromCache(Mantra & m, BasicTree & tree, String & marker)
   {
   if (!isActive || dataFile == NULL || indexFile == NULL || m.bit_count < 4)
      return false;

   int where = markers.Integer(marker + tag);

   if (where == -1)
      return false;

   fseek(dataFile, where, SEEK_SET);

   // First check whether genotypes array matches
   longint genotype;
   for (int i = 0; i < m.two_n; i++)
      if (fread(&genotype, sizeof(genotype), 1, dataFile) != 1 ||
          genotype != m.genotype[i])
          return false;

   // Next check whether allele frequency array matches
   double frequency;
   for (int i = 0; i < m.frequencies.Length(); i++)
      if (fread(&frequency, sizeof(frequency), 1, dataFile) != 1 ||
          frequency != m.frequencies[i])
          return false;

   // Read inheritance tree
   tree.ReadFromFile(dataFile);
   return true;
   }
 
